// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
)

const findTxnInVssNotMqt = `-- name: FindTxnInVssNotMqt :many
WITH vssTxn_counts AS (
    SELECT amount, COUNT(*) AS cnt
    FROM vssTxn
    GROUP BY amount
),
mqtTxn_counts AS (
    SELECT purchases AS amount, COUNT(*) AS cnt
    FROM mqtTxn
    GROUP BY purchases
),
excess_in_vss AS (
    SELECT vtc.amount
    FROM vssTxn_counts vtc
    LEFT JOIN mqtTxn_counts mtc
    ON vtc.amount = -mtc.amount
    WHERE vtc.cnt > COALESCE(mtc.cnt, 0)
)
SELECT
    vt.uuid, vt.created_at, vt.amount, vt.merchant, vt.settlement_date, vt.purchase_date, vt.currency, vt.approval_number, vt.int_fee, vt.merchant_country, vt.type
FROM
    vssTxn vt
JOIN
    excess_in_vss eiv
ON
    vt.amount = eiv.amount
`

func (q *Queries) FindTxnInVssNotMqt(ctx context.Context) ([]Vsstxn, error) {
	rows, err := q.db.Query(ctx, findTxnInVssNotMqt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vsstxn
	for rows.Next() {
		var i Vsstxn
		if err := rows.Scan(
			&i.Uuid,
			&i.CreatedAt,
			&i.Amount,
			&i.Merchant,
			&i.SettlementDate,
			&i.PurchaseDate,
			&i.Currency,
			&i.ApprovalNumber,
			&i.IntFee,
			&i.MerchantCountry,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
